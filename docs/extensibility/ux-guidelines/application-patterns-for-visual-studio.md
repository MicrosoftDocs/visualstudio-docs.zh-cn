---
title: 应用程序应用程序模式Visual Studio |Microsoft Docs
description: 了解文档窗口、工具窗口和无模式对话框的区别，包括适用于 Visual Studio 的新功能的窗口使用模式。
ms.custom: SEO-VS-2020
ms.date: 04/26/2017
ms.topic: reference
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: leslierichardson95
ms.author: lerich
manager: jmartens
ms.workload:
- vssdk
ms.openlocfilehash: 2726c7096bbf4606fbab2c32b01ffd197549e13c
ms.sourcegitcommit: bab002936a9a642e45af407d652345c113a9c467
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/25/2021
ms.locfileid: "112899181"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio 的应用程序模式
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a> 窗口交互

### <a name="overview"></a>概述
在编辑器中使用的两种Visual Studio是文档编辑器和工具窗口。 大型无模式对话很少见，但可能。 尽管这些在 shell 中都是无模式的，但模式基本不同。 本部分介绍文档窗口、工具窗口和无模式对话的区别。 模式对话模式在对话 [中介绍](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)。

### <a name="comparing-window-usage-patterns"></a>比较窗口使用模式
**文档窗口** 几乎总是显示在文档井中。 这为文档编辑器提供了一个"中心阶段"来安排补充工具窗口。

**工具窗口** 通常显示为与 IDE 边缘折叠的单独较小窗口。 这可以是可见、隐藏或自动隐藏的。 但是，有时工具窗口通过取消选中窗口 **上的 Window/Docking** 属性在文档井中显示。 这可产生更多空间，但也会导致常见的设计决策：尝试集成到 Visual Studio 时，必须确定功能应显示工具窗口还是文档窗口。

**建议不要将无** 模式对话Visual Studio。 根据定义，大多数无模式对话都是浮动工具窗口，应按此方式实现。 如果停靠在 shell 一侧的正常工具窗口的大小过于有限，则允许无模式对话。 如果用户可能将对话移动到辅助监视器，则也允许使用它们。

请仔细考虑所需的容器类型。 下表列出了 UI 设计的常见使用模式注意事项。

||文档窗口|工具窗口|无模式对话框|
|-|---------------------|-----------------|---------------------|
| **位置** | 始终定位在文档井中，不会停靠在 IDE 的边缘周围。 它可以"拉取"，以便与主 shell 分开浮动。 | 通常，选项卡停靠在 IDE 的边缘周围，但可自定义为浮动、自动隐藏 (取消固定) 或停靠在文档井中。|与 IDE 分离的大型浮动窗口。 |
| **提交模型** | *延迟提交*<br /><br /> 为了将数据保存在文档中，用户必须发出"文件保存"、"另 **&gt;****存** 为"或"**全部保存"** 命令。 文档窗口包含数据的概念，即"已创建"，然后提交到其中一个保存命令。 关闭文档窗口时，所有内容都保存到磁盘或丢失。 | *立即提交*<br /><br /> 没有保存模型。 对于有助于编辑文件的检查器工具窗口，该文件必须在活动编辑器或设计器中打开，并且编辑器或设计器拥有保存。 | *延迟提交或立即提交*<br /><br /> 大多数情况下，大型无模式对话需要一个操作来提交更改，并允许执行"取消"操作，该操作会回滚在对话会话中进行的任何更改。  这区分了无模式对话框和工具窗口中的工具窗口始终具有即时提交模型。 |
| **可见性** | *打开/创建 (文件) 关闭*<br /><br /> 打开文档窗口是通过打开现有文档或使用模板创建新文档完成。 没有"打开 \<specific editor> "命令。 | *隐藏和显示*<br /><br /> 可以隐藏或显示单实例工具窗口。 无论处于视图中还是隐藏状态，工具窗口中的内容和状态都仍然存在。 多实例工具窗口可以关闭，也可以隐藏。 当多实例工具窗口关闭时，工具窗口中的内容和状态将被丢弃。 | *从命令启动*<br /><br /> 对话从基于任务的命令启动。 |
| **实例** | *多实例*<br /><br /> 可以同时打开多个编辑器并编辑不同的文件，而某些编辑器还允许使用"窗口""新建窗口"命令 (多个编辑器中打开同一) 。 **&gt;**<br /><br /> 单个编辑器可以在项目设计器中同时编辑 (一) 。 | *单实例或多实例*<br /><br /> 内容会更改以反映上下文 (如属性浏览器) 或将焦点/上下文推送到其他窗口 (任务列表，解决方案资源管理器) 。<br /><br /> 除非有令人信服的理由，否则单实例和多实例工具窗口都应与活动文档窗口相关联。 | *单实例* |
| **示例** | **文本编辑器**，如代码编辑器<br /><br /> **设计图面**，如窗体设计器或建模图面<br /><br /> **类似于对话框的控件布局，** 如清单设计器 | 该 **解决方案资源管理器** 提供了解决方案中包含的解决方案和项目<br /><br /> 该 **服务器资源管理器** 提供了用户选择在窗口中打开的服务器和数据连接的层次结构视图。 从数据库层次结构打开对象（如查询）会打开一个文档窗口，允许用户编辑查询。<br /><br /> 属性 **浏览器** 显示文档窗口或其他工具窗口中所选对象的属性。 这些属性在分层网格视图或类似对话框的复杂控件中显示，允许用户设置这些属性的值。 | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a> 工具窗口

### <a name="overview"></a>概述
工具窗口支持在文档窗口中发生的用户工作。 它们可用于显示一个层次结构，该层次结构表示一个基本的根对象，Visual Studio和可以操作。

考虑 IDE 中的新工具窗口时，作者应：

- 使用适合任务的现有工具窗口，而不是创建具有类似功能的新工具窗口。 只有在新工具窗口提供明显不同的"工具"或无法集成到类似窗口的功能，或者将现有窗口转换为透视中心时，才应创建新工具窗口。

- 如果需要，请使用工具窗口顶部的标准命令栏。

- 与其他工具窗口中已存在的模式保持一致，以控制控件呈现和键盘导航。

- 与其他工具窗口中的控件表示形式保持一致。

- 尽可能使特定于文档的工具窗口自动可见，以便仅在激活父文档时显示它们。

- 确保其窗口内容通过键盘导航， (箭头键) 。

#### <a name="tool-window-states"></a>工具窗口状态
Visual Studio工具窗口具有不同的状态，其中一些状态是用户激活 (如自动隐藏功能) 。 其他状态（如自动可见）允许工具窗口出现在正确的上下文中，并根据需要隐藏。 共有五种工具窗口状态。

- **停靠/固定工具** 窗口可以附加到文档区域四侧的任何一侧。 图钉图标将显示在工具窗口标题栏中。 工具窗口可以沿 shell 和其他工具窗口的边缘水平或垂直停靠，也可以进行选项卡链接。

- **自动隐藏的工具** 窗口未固定。 窗口可能会滑出视线，使选项卡 (工具窗口的名称及其图标) 位于文档区域的边缘。 用户将鼠标悬停在选项卡上时，工具窗口会滑出。

- **当另一** 个 UI（如编辑器）启动或获得焦点时，自动可见的工具窗口会自动显示。

- **浮动** 工具窗口将鼠标悬停在 IDE 外部。 这适用于多监视器配置。

- **选项卡式** 文档工具窗口可以停靠在文档井中。 这适用于大型工具窗口（如对象浏览器）需要比停靠框架边缘更多的空间。

![Visual Studio 中的“工具”窗口状态](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Visual Studio 中的“工具”窗口状态

#### <a name="single-instance-and-multi-instance"></a>单实例和多实例
工具窗口是单实例或多实例。 某些单实例工具窗口可能与活动文档窗口相关联，而多实例工具窗口可能不会。 多实例工具窗口通过创建新的窗口实例来响应 **窗口 " &gt; 新建窗口** " 命令。 下图演示了一个工具窗口，该窗口在窗口的实例处于活动状态时启用 "新建窗口" 命令：

![在窗口的实例处于活动状态时启用 "新建窗口" 命令的工具窗口](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />在窗口的实例处于活动状态时启用 "新建窗口" 命令的工具窗口

可以隐藏或显示单实例工具窗口，而多实例工具窗口可以关闭并隐藏。 所有工具窗口都可以停靠、选项卡链接、浮动或设置为 Multiple-Document 接口 (MDI) 子窗口 (与文档窗口) 类似。 所有工具窗口都应在 "窗口" 菜单中响应适当的窗口管理命令：

![Visual Studio 窗口菜单中的窗口管理命令](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />Visual Studio 窗口菜单中的窗口管理命令

#### <a name="document-specific-tool-windows"></a>文档特定的工具窗口
某些工具窗口旨在根据给定类型的文档进行更改。 这些 windows 不断更新，以反映适用于 IDE 中的活动文档窗口的功能。

"工具箱" 和 "文档大纲" 中其内容更改以反映所选编辑器的工具窗口的示例。 当编辑器有焦点不提供窗口上下文时，这些窗口将显示水印。

#### <a name="navigable-list-tool-windows"></a>可导航列表工具窗口
某些工具窗口显示用户可与之交互的可导航项的列表。 在此类型的窗口中，对于列表中的当前项应始终有反馈，即使窗口处于非活动状态也是如此。 此列表还应通过更改窗口中当前选定的项来响应 **GoToNextLocation** 和 **GoToPrevLocation** 命令。

可导航列表工具窗口的示例包括 "解决方案资源管理器" 和 "查找结果" 窗口。

### <a name="tool-window-types"></a>工具窗口类型

#### <a name="common-tool-windows-and-their-functions"></a>常见工具窗口及其功能

**分层工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 解决方案资源管理器 | 显示项目、杂项文件和解决方案项中包含的文档列表的层次结构树。 项目中项的显示由拥有项目类型的包定义 (例如，基于引用、基于目录或混合模式的类型) 。 |
| 类视图 | 类和文档工作集中各个元素的层次结构树，独立于文件本身。 |
| 服务器资源管理器 | 显示解决方案中所有服务器和数据连接的层次结构树。 |
| 文档大纲 | 活动文档的层次结构。 |

**网格工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 属性 | 该网格显示所选对象的属性列表，以及值选取器来编辑这些属性。 |
| 任务列表 | 允许用户创建/编辑/删除任务和注释的网格。 |

**内容工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 帮助 | 允许用户从 "如何实现" 访问获得帮助的各种方法的窗口 视频到 MSDN 论坛。 |
| 动态帮助 | 显示适用于当前所选内容的帮助主题的链接的工具窗口。 |
| 对象浏览器 | 一个包含两列的框架集，其中包含左窗格中的分层对象组件列表，以及右侧列中对象的属性和方法。 |

**对话框工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 查找 | 此对话框允许用户在解决方案内的各种文件中查找或查找和替换。 |
| 高级查找 | 此对话框允许用户在解决方案内的各种文件中查找或查找和替换。 |

**其他工具窗口**

::: moniker range="vs-2017"

| 工具窗口 | 功能 |
| --- | --- |
| 工具箱 | 用于存储将放置到设计图面上的元素的工具窗口，为所有设计器提供一致的拖放。 |
| 起始页 | 用户使用 Visual Studio 的门户，可以访问开发人员新闻、Visual Studio 帮助和最新项目的源。 用户还可以通过将 StartPage .xaml 文件从 "Common7\IDE\StartPages \" Visual studio program files" 目录复制到 Visual studio 文档目录中的 "StartPages" 文件夹，然后在 Visual studio 或其他代码编辑器中手动编辑或打开该 xaml 来创建自定义起始页。 |

::: moniker-end

::: moniker range=">=vs-2019"

| 工具窗口 | 功能 |
| --- | --- |
| 工具箱 | 用于存储将放置到设计图面上的元素的工具窗口，为所有设计器提供一致的拖放。 |

::: moniker-end

**调试器工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 自动 ||
| 即时 ||
| 输出 | 如果要声明文本事件或状态，则可以使用 "输出" 窗口。 |
| 内存 ||
| 断点 ||
| 运行 ||
| 文档 ||
| 调用堆栈 ||
| 局部变量 ||
| 监视 ||
| 反汇编 ||
| 寄存器 ||
| 线程数 ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a> 文档编辑器约定

### <a name="document-interactions"></a>文档交互
"文档很好" 是 IDE 中的最大空间，用户通常会重点关注如何完成其任务，如补充工具窗口。 文档编辑器表示用户在 Visual Studio 中打开并保存的基本工作单元。 它们保持了与解决方案资源管理器或其他活动层次结构窗口相关的更好选择。 用户应该能够指向这些层次结构窗口中的一个窗口，知道文档包含的位置及其与解决方案、项目或 Visual Studio 包提供的其他根对象之间的关系。

文档编辑需要一致的用户体验。 若要允许用户将精力集中在任务上，而不是使用窗口管理和查找命令，请选择最适合于编辑该文档类型的用户任务的文档视图策略。

#### <a name="common-interactions-for-the-document-well"></a>文档的常见交互

- 在常见的 **新文件** 中维护一致的交互模型，并 **打开文件** 体验。

- 当文档窗口打开时，更新相关窗口和菜单中的相关功能。

- 菜单命令已适当地集成到常见菜单中，如 **编辑**、 **格式** 和 **视图** 菜单。 如果大量专用命令可用，可以创建一个新菜单。 只有在文档具有焦点时，此新菜单才可见。

- 嵌入的工具栏可以放置在编辑器的顶部。 这比在编辑器外部显示单独的工具栏更可取。

- 始终在活动层次结构窗口解决方案资源管理器保持选定内容。

- 双击文档中的文档解决方案资源管理器应执行与打开 相同的 **操作**。

- 如果文档类型上可以使用多个编辑器，则用户应该能够通过使用"打开方式"对话框，通过右键单击文件，然后从快捷菜单中选择"打开方式"来替代或重置给定文档类型的默认操作。 

- 请勿在文档中生成向导。

### <a name="user-expectations-for-specific-document-types"></a>用户对特定文档类型的预期
有几个不同类型的文档编辑器，每种编辑器都有一组与相同类型的其他编辑器一致的交互。

- **基于文本的编辑器：** 代码编辑器、日志文件

- **设计图面：** WPF 窗体设计器、Windows 窗体

- **对话框样式编辑器：** 清单设计器， 项目属性

- **模型设计器：** 工作流设计器、代码图、体系结构关系图、进度

还有几种使用文档的非编辑器类型。 尽管它们本身不编辑文档，但他们需要遵循文档窗口的标准交互。

- **报表：** IntelliTrace 报表、Hyper-V 报表、探查器报表

- **仪表板：** 诊断中心

#### <a name="text-based-editors"></a>基于文本的编辑器

- 文档参与预览选项卡模型，允许在不打开文档的情况下预览文档。

- 文档的结构可以在配套工具窗口（如文档大纲）中表示。

- IntelliSense (在适当) 将与其他代码编辑器一致地运行。

- 弹出窗口或辅助 UI 遵循现有类似 UI（如 CodeLens）的类似样式和模式。

- 有关文档状态的消息将在文档顶部的信息栏控件或状态栏中显示。

- 用户必须能够使用"工具">"页（共享" **字体和颜色"** 页或特定于编辑器的页面）自定义字体和颜色的外观。

#### <a name="design-surfaces"></a>设计图面

- 空设计器在图面上应具有一个水印，指示如何开始。

- 视图切换机制将遵循现有模式，例如双击打开代码编辑器或文档窗口中允许与两个窗格交互的选项卡。

- 除非需要高度特定的工具窗口，否则应该通过"工具箱"向设计图面添加元素。

- 图面上的项将遵循一致的选择模型。

- 嵌入的工具栏仅包含特定于文档的命令，而不包含保存 等 **常见命令**。

#### <a name="dialog-style-editors"></a>对话框样式编辑器

- 控件布局应遵循正常的对话框布局约定。

- 编辑器中的选项卡不应与文档选项卡的外观匹配，它们应匹配两个允许的内部选项卡样式之一。

- 用户只能使用键盘与控件交互;通过激活编辑器并按 Tab 键通过控件，或者使用标准助记键。

- 设计器应该使用常见的"保存"模型。 图面上不应放置整体的"保存"或"提交"按钮，尽管其他按钮可能合适。

#### <a name="model-designers"></a>模型设计器

- 空设计器在图面上应具有一个水印，指示如何开始。

- 应该通过"工具箱"向设计图面添加元素。

- 图面上的项将遵循一致的选择模型。

- 嵌入的工具栏仅包含特定于文档的命令，而不包含保存 等 **常见命令**。

- 图例可能显示在图面上，指示性或水印。

- 用户必须能够使用"工具">"页（共享"字体 **和颜色"** 页或特定于编辑器的页面）自定义字体/颜色的外观。

#### <a name="reports"></a>报表

- 报表通常只提供信息，不参与"保存"模型。 但是，它们可能包括交互，例如指向其他相关信息的链接或展开和折叠的部分。

- 图面上大多数命令应为超链接，而不是按钮。

- 布局应包含标头，并遵循标准报表布局准则。

#### <a name="dashboards"></a>仪表板

- 仪表板本身没有交互模型，但充当提供各种其他工具的一种途径。

- 它们不参与保存模型。

- 用户只能使用键盘通过激活编辑器并按 Tab 键通过控件或标准助记键来与控件进行交互。

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a> 对话 框

### <a name="introduction"></a>简介
用户Visual Studio对话通常应支持用户工作的一个离散单元，然后被关闭。

如果已确定需要对话，则按偏好顺序有三种选择：

1. 将功能集成到 Visual Studio 中的共享对话之一。

2. 使用现有类似对话中的模式创建自己的对话。

3. 按照交互和布局指南创建新对话框。

本部分介绍如何在工作流中选择正确的Visual Studio模式以及对话框设计的常见约定。

### <a name="themes"></a>主题
对话框中的Visual Studio遵循以下两种基本样式之一：

#### <a name="standard-unthemed"></a>标准 (无) 
大多数对话是标准实用工具对话，应取消其名称。 请勿重新模板化公共控件或尝试创建样式化的"新式"按钮或控件。 控件和 chrome 外观遵循 [对话框 的标准 Windows 桌面交互准则](/windows/desktop/uxguide/win-dialog-box)。

#### <a name="themed"></a>主题
可以以专用"签名"对话框为特色。 有色对话具有不同的外观，它还具有一些与样式关联的特殊交互模式。 仅在对话框满足以下要求时，才对对话进行主题设置：

- 对话框是一种常见体验，它经常出现并供许多用户使用 (例如"新建项目 **"对话框。**

- 该对话框包含重要的产品品牌 (例如，"帐户 **设置** "对话框) 。

- 该对话框显示为较大流的组成部分，其中包括其他 (对话框，例如 **，"添加** 连接的服务"对话框) 。

- 对话是体验的重要组成部分，在推广或区分产品版本方面具有战略作用。

创建主题对话时，请使用适当的环境颜色，并遵循正确的布局和交互模式。  ([.Visual Studio](../../extensibility/ux-guidelines/layout-for-visual-studio.md)的布局) 

### <a name="dialog-design"></a>对话设计
设计良好的对话会考虑以下元素：

- 支持的用户任务

- 对话文本样式、语言和术语

- 控件选择和 UI 约定

- 视觉布局规范和控件对齐方式

- 键盘访问

#### <a name="content-organization"></a>内容组织
请考虑这些基本类型的对话之间的差异：

- [简单对话框在](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) 单个模式窗口中显示控件。 演示文稿可能包括复杂控件模式的变体，包括字段选取器或图标栏。

- [当一段](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs) UI 包含多个控件组时，分层对话用于充分利用屏幕空间。 对话框的分组通过选项卡控件、导航列表控件或按钮"分层"，以便用户可以选择在任何给定时刻查看哪个分组。

- [向导](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) 可用于指导用户完成任务的逻辑步骤序列。 顺序面板中提供了一系列选择，有时引入不同的工作流 ("分支) 取决于上一面板中所做的选择。

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a> 简单对话
简单对话是在单个模式窗口中呈现控件。 此演示可能包括复杂控件模式（如字段选取器）的变体。 对于简单对话，请遵循标准常规布局以及复杂控件分组所需的任何特定布局。

![>强名称密钥"是创建强名称密钥中的一个简单Visual Studio。](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />"创建强名称密钥"是一个简单的对话框示例，Visual Studio。

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a> 分层对话
分层对话框包括选项卡、仪表板和嵌入的树。 当单个 UI 中提供了多个控件组时，它们用于最大化房地产。 对分组进行分层，以便用户可以选择随时查看的分组。

在最直接的情况下，在分组之间切换的机制是选项卡控件。 有几种替代方法可用。 请参阅确定优先级和分层，了解如何选择最合适的样式。

" **工具 &gt; 选项** "对话框是使用嵌入树的分层对话的示例：

![">选项"是"选项"中分层对话框Visual Studio。](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />">选项"是"选项"中分层对话框Visual Studio。

#### <a name="wizards"></a><a name="BKMK_Wizards"></a> 向导
向导可用于指导用户完成任务的逻辑步骤序列。 顺序面板中提供了一系列选项，用户必须继续执行每个步骤，然后才能继续下一步。 有足够的默认值可用后，将启用 **"完成** "按钮。

 模式向导用于以下任务：

- 包含分支，其中提供不同的路径，具体取决于用户选择

- 包含步骤之间的依赖关系，其中后续步骤依赖于上一步骤中的用户输入 () 

- 足够复杂，应该使用 UI 解释所提供的选择以及每个步骤中可能的结果

- 是事务性的，要求在提交任何更改之前完整完成一组步骤

### <a name="common-conventions"></a>常见约定
若要通过对话实现最佳设计和功能，请遵循有关对话框大小、位置、标准、控制配置和对齐、UI 文本、标题栏、控制按钮和访问键的这些约定。

有关特定于布局的准则，请参阅[布局Visual Studio。](../../extensibility/ux-guidelines/layout-for-visual-studio.md)

#### <a name="size"></a>大小
对话应不超过 1024x768 屏幕分辨率，初始对话大小不应超过 900x700 像素。 对话框可以调整大小，但这不是一项要求。

对于可调整大小的对话，有两个建议：

1. 该最小大小是为对话框定义的，该对话框将针对控件集进行优化而不进行剪辑，并进行调整以适应合理的本地化增长。

2. 用户缩放的大小在会话与会话保持一样。 例如，如果用户将对话缩放到 150%，则对话框的后续启动将显示为 150%。

#### <a name="position"></a>位置
首次启动时，对话框必须在 IDE 中居中显示。 不可调整大小对话的最后一个位置不需要持久化，因此它们将在后续启动时居中显示。

对于可调整大小的对话，应在后续启动时保留大小。 对于可调整大小的模式对话框，无需保留位置。 在 IDE 中居中显示它们可防止对话框在用户的显示配置发生更改时出现在不可预知或不可用的位置。

对于可重新定位的无模式对话，应在后续启动时保持用户的位置，因为对话可能经常用作较大工作流的组成部分。

当对话必须生成其他对话时，最顶层的对话应从父级向右和向下级联，以便用户明显看到它们已导航到新位置。

#### <a name="modality"></a>形态
作为模式意味着用户需要先完成或取消对话，然后才能继续。 由于模式对话会阻止用户与环境的其他部分交互，因此功能的任务流应尽量少使用它们。 如果需要模式操作，Visual Studio多个共享对话，你可以将功能集成到其中。 如果必须创建新对话，请遵循具有类似功能的现有对话的交互模式。

当用户需要一次执行两个活动（如在编写新代码时查找和替换）时，对话框应为无模式，以便用户可以轻松地在它们之间切换。 Visual Studio此类支持编辑器的链接任务，通常使用工具窗口。

#### <a name="control-configuration"></a>控制配置
与现有的控制配置保持一致，这些配置在Visual Studio。

#### <a name="title-bars"></a>标题栏

- 标题栏中的文本必须反映启动它的命令的名称。

- 不应在对话框标题栏内使用图标。 如果系统需要一个，请使用Visual Studio徽标。

- 对话框不应具有最小化或最大化按钮。

- 标题栏中的帮助按钮已弃用。 请勿将它们添加到新对话框中。 当它们存在时，他们应启动一个在概念上与任务相关的帮助主题。

  ![对话框中标题栏Visual Studio规范](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />对话框中标题栏Visual Studio规范

#### <a name="control-buttons"></a>控件按钮
通常 **，"确定****"、"** 取消"和"帮助"按钮应水平排列在对话框右下角。 如果对话框底部有几个其他按钮，则允许使用备用垂直堆栈，这些按钮会导致与控件按钮产生视觉混淆。

![对话框中控制按钮的可接受Visual Studio配置](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />对话框中控制按钮的可接受Visual Studio配置

该对话框必须包含默认控件按钮。 若要确定用作默认值的最佳命令，请从以下选项中进行选择 (按优先级顺序) ：

- 选择最安全且最安全的命令作为默认值。 这意味着选择命令最有可能防止数据丢失并避免意外的系统访问。

- 如果数据丢失和安全性不是因素，请根据便利性选择默认命令。 当对话框支持频繁或重复的任务时，将最可能的命令包括为默认值将改进用户的工作流。

避免为默认命令选择永久破坏性操作。 如果存在此类命令，请改为选择更安全的命令作为默认值。

#### <a name="access-keys"></a>访问键
请勿将访问密钥用于 **"确定"、"****取消**"或"**帮助"** 按钮。 默认情况下，这些按钮映射到快捷键：

| 按钮名称 | 键盘快捷方式 |
| --- | --- |
| 确定 | Enter |
| 取消 | Esc |
| 帮助 | F1 |

#### <a name="imagery"></a>图像
在对话框中谨慎使用图像。 请勿在对话框中使用大图标，而只是占用空间。 只有在图像是向用户传达消息的重要部分（如警告图标或状态动画）时，才使用图像。

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a> 确定优先级和分层

#### <a name="prioritizing-your-ui"></a>确定 UI 的优先级
可能需要将某些 UI 元素放在最前面，将更高级的行为和选项放在 (包括) 对话框中。 通过为常用功能提供空间，在显示对话框时在 UI 中默认使用文本标签使其可见，从而将常用功能引入最前面。

#### <a name="layering-your-ui"></a>对 UI 进行分层
如果已确定对话框是必需的，但要呈现给用户的相关功能超出了简单对话框中可显示的功能，则需要对 UI 进行分层。 最常用的分层方法Visual Studio选项卡、仪表板或仪表板。 在某些情况下，可以展开和折叠的区域可能很合适。 通常不建议在应用Visual Studio。

通过类似选项卡的控件对 UI 进行分层的不同方法有优点和缺点。 查看以下列表，确保选择适合你的情况的分层技术。

##### <a name="tabbing"></a>Tab 键次序

| 切换机制 | 优点和适当使用 | 缺点和不当使用 |
| --- | --- | --- |
| Tab 控件 | 以逻辑方式将对话框页分组到相关集<br /><br />对于少于五个 (或对话框中一行的选项卡数很有用，) 对话框中相关控件的页面<br /><br />选项卡标签必须为 short：一个或两个单词，可轻松地识别内容<br /><br />常见系统对话框样式<br /><br />示例： **文件资源管理器 &gt; 项属性** | 可能很难进行描述性简短标签<br /><br />通常不会在一个对话框中缩放过去的五个选项卡<br /><br />如果一个行的选项卡太多 (使用替代分层技术) <br /><br />不可扩展 |
| 边栏导航 | 可以容纳超过选项卡的多个类别的简单切换设备<br /><br />不 (层次结构的类别的简单列表) <br /><br />可扩展<br /><br />示例： **自定义 ... &gt; 添加命令** | 如果少于三个组，则不能使用水平空间。<br /><br />任务可能更适合下拉 |
| 树控件 | 允许无限制类别<br /><br />允许对类别进行分组和/或层次结构<br /><br />可扩展<br /><br />示例： **工具 &gt; 选项** | 高度嵌套的层次结构可能导致过多的水平滚动<br /><br />Visual Studio 具有 overabundance 树视图 |
| 向导 | 通过基于任务的顺序步骤指导用户完成任务完成：向导表示高级任务，而各个面板代表完成总体任务所需的子任务<br /><br />当任务跨越 Ui 边界时非常有用，因为当用户需要使用多个编辑器和工具窗口完成任务时，<br /><br />当任务需要分支时有用<br /><br />当任务包含步骤间的依赖关系时有用<br /><br />在一个对话框中显示多个具有一个决策分叉的类似任务时，此方法非常有用，可减少不同相似对话框的数量 | 不适用于不需要顺序工作流的任何任务<br /><br />如果向导执行的操作过多，可能会使用户感到不知所措和混淆<br /><br />向导在本质上是有限的屏幕 |

##### <a name="hallways-or-dashboards"></a>走廊或仪表板
走廊和仪表板是对话框或面板，它们充当其他对话框和窗口的启动点。 设计良好的 "走廊" 立即只显示最常见的选项、命令和设置，使用户能够轻松完成常见任务。 与现实世界走廊提供两侧来访问他们后面的聊天室，这里的常见 UI 会被收集到单独的 "房间" 中 (通常其他对话框) 可从主要走廊访问的相关功能。

或者，在单个集合中提供所有可用功能的 UI，而不是将不太常见的功能重构到不同的位置，只是一个仪表板。

![在 Outlook 中公开附加 UI 的走廊概念](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />在 Outlook 中公开附加 UI 的走廊概念

##### <a name="adaptive-ui"></a>自适应 UI
显示或隐藏基于使用情况或用户的自报告体验的 UI 是在隐藏其他部分的同时提供必要 UI 的另一种方法。 不建议在 Visual Studio 中使用这种方式，因为用于决定何时显示或隐藏 UI 的算法可能比较棘手，并且对于某些事例集，规则将始终错误。

## <a name="projects"></a><a name="BKMK_Projects"></a> 投射

### <a name="projects-in-the-solution-explorer"></a>解决方案资源管理器中的项目
大多数项目归类为基于引用、基于目录或混合。 解决方案资源管理器中同时支持所有这三种类型的项目。 使用项目的用户体验的根本发生在此窗口内。 尽管不同的项目节点是引用、目录或混合模式类型项目，但在拆分为特定于项目的用户模式之前，还应将常见交互模式应用为起点。

项目应始终：

- 支持添加项目文件夹来组织项目内容的功能

- 为项目持久性维护一致的模型

项目还应为以下各内容维护一致的交互模型：

- 删除项目项

- 保存文档

- 项目属性编辑

- 在替代视图中编辑项目

- 拖放操作

### <a name="drag-and-drop-interaction-model"></a>拖放交互模型
项目通常会将自身分类为基于引用的 (只能保留对存储) 中的项目项的引用，基于目录的 (能够仅保存物理存储在项目层次结构中的项目项) ，或混合 (能够将引用或物理项保存) 。 IDE 在 **解决方案资源管理器** 中同时容纳所有三种类型的项目。

从拖放角度来看，以下特性应该适用于 **解决方案资源管理器** 中的每种类型的项目：

- **基于引用的项目：** 关键在于，项目是围绕存储中的项的引用进行拖动。 当基于引用的项目用作移动操作的源时，它只应从项目中删除对该项的引用。 不应实际从硬盘中删除该项。 当基于引用的项目作为 move (或 copy) 操作的目标时，它应添加对原始源项的引用，而无需创建该项的私有副本。

- **基于目录的项目：** 从拖放的角度来看，项目在物理项（而不是引用）上拖动。 当基于目录的项目用作移动操作的源时，它应最终将物理项目从硬盘删除，并将其从项目中删除。 当基于目录的项目作为 move (或 copy) 操作的目标时，它应在其目标位置生成源项的副本。

- **混合目标项目：** 从拖放的角度来看，这种类型的项目的行为基于要拖动的项的性质 (引用存储中的项或) 项本身。 上文介绍了引用和物理项的正确行为。

如果 **解决方案资源管理器** 中只有一种类型的项目，则拖放操作非常简单。 由于每个项目系统都可以定义自己的拖放行为，因此应遵循特定的准则 (基于 Windows 资源管理器拖放) 行为，以确保可预测的用户体验：

- 当按住 Ctrl 键或 Shift 键时， **解决方案资源管理器** (中未修改的拖动操作) 应导致移动操作。

- Shift + 拖动操作还应导致移动操作。

- 按住 Ctrl 键的同时操作将导致复制操作。

- 基于引用和混合的项目系统支持添加链接 (或引用) 到源项的概念。 当这些项目是拖放操作的目标时 (在按住 **Ctrl + Shift**) 时，它应导致对要添加到项目中的项的引用。

并非所有拖放操作都适用于基于引用、基于目录和混合项目的组合。 具体而言，假设允许在基于目录的源项目与基于引用的目标项目之间进行移动操作是有问题的，因为基于源目录的项目在移动完成后必须删除源项。 然后，基于目标引用的项目最终将引用已删除的项。

它还会误导您在这些类型的项目之间允许复制操作，因为基于目标引用的项目不应创建源项的独立副本。 同样，不应允许使用 Ctrl + Shift 拖动到基于目录的目标项目，因为基于目录的项目无法保留引用。 在不支持拖放操作的情况下，IDE 应禁止放置，并向用户显示 "不删除" 光标 (如下) 中的指针表中所示。

为了正确实现拖放行为，拖动的源项目需要将其性质传达给目标项目。  (例如，是基于引用还是基于目录的？ ) 此信息由源提供的剪贴板格式指示。 作为拖动 (或剪贴板复制操作的源) 项目应提供 `CF_VSREFPROJECTITEMS` 或 `CF_VSSTGPROJECTITEMS` 分别提供，具体取决于该项目是基于引用还是基于目录。 这两种格式都具有相同的数据内容，这与 Windows 格式类似， `CF_HDROP` 但字符串列表不同于 Windows 格式，而不是文件名，是 `NULL` 从 (返回的字符串的双终止列表， `Projref` `IVsSolution::GetProjrefOfItem` 或 `::GetProjrefOfProject` 作为适当的) 。

作为) 的 drop (或剪贴板粘贴操作的目标，项目应同时接受 `CF_VSREFPROJECTITEMS` 和 `CF_VSSTGPROJECTITEMS` ，尽管拖放操作的确切处理因目标项目和源项目的性质而异。 源项目根据其提供还是来声明其本质 `CF_VSREFPROJECTITEMS` `CF_VSSTGPROJECTITEMS` 。 Drop 的目标理解自己的性质，因此具有足够的信息来决定是否应执行移动、复制或链接。 用户还可以通过按 ctrl、Shift 或同时按 Ctrl 键和 Shift 键来修改应执行的拖放操作。 放置目标正确指示将在其和方法中提前执行的操作非常重要 `DragEnter` `DragOver` 。 **解决方案资源管理器** 会自动知道源项目和目标项目是否为同一个项目。

在 Visual Studio 的实例间拖动项目项 (例如，特别不支持从一个 devenv.exe 实例到另一个) 。 **解决方案资源管理器** 也直接禁用了此。

用户应始终能够通过以下方式确定拖放操作的效果：选择一个项，将其拖至目标位置，然后观察在该项被删除之前出现的以下鼠标指针：

| 鼠标指针 | 命令 | 描述 |
| :---: | --- | --- |
| ![鼠标“不放下”图标](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | 不删除 | 无法将项拖放到指定位置。 |
| ![鼠标“复制”图标](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | 复制 | 项将复制到目标位置。 |
| ![鼠标“移动”图标](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | 移动 | 项将移动到目标位置。 |
| ![鼠标“添加引用”图标](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | 添加引用 | 对所选项的引用将添加到目标位置。 |

#### <a name="reference-based-projects"></a>基于引用的项目
 下表汇总了拖放 (以及应该根据为基于引用的目标项目按下的源项和修饰符键的性质执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 `CF_HDROP` ()  |
| --- | --- | --- | --- |
| 无修饰符 | 操作 | 移动 | 链接 |
| 无修饰符 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| 无修饰符 | 源 | 删除对原始项的引用 | 保留原始项 |
| 无修饰符 | 结果 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_LINK` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Shift+拖动 | 操作 | 移动 | 无删除 |
| Shift+拖动 | 目标 | 添加对原始项的引用 | 无删除 |
| Shift+拖动 | 源 | 删除对原始项的引用 | 无删除 |
| Shift+拖动 | 结果 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | 无删除 |
| Ctrl+拖动 | 操作 | 复制 | 无删除 |
| Ctrl+拖动 | 目标 | 添加对原始项的引用 | 无删除 |
| Ctrl+拖动 | 源 | 保留对原始项的引用 | 无删除 |
| Ctrl+拖动 | 结果 | `DROPEFFECT_COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | 无删除 |
| Ctrl+Shift+拖动 | 操作 | 链接 | 链接 |
| Ctrl+Shift+拖动 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| Ctrl+Shift+拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl+Shift+拖动 | 结果 | `DROPEFFECT_LINK` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_LINK` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+Shift+拖动 | 注意 | 与中快捷方式的拖放行为Windows 资源管理器。 ||
| 剪切/粘贴 | 操作 | 移动 | 链接 |
| 剪切/粘贴 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| 剪切/粘贴 | 源 | 保留对原始项的引用|保留原始项 |
| 剪切/粘贴 | 结果 | 项保留在存储中的原始位置 | 项保留在存储中的原始位置 |
| 复制/粘贴 | 操作 | 复制 | 链接 |
| 复制/粘贴 | 源 | 添加对原始项的引用 | 添加对原始项的引用 |
| 复制/粘贴 | 结果 | 保留对原始项的引用 | 保留原始项 |
| 复制/粘贴 | 操作 | 项保留在存储中的原始位置 | 项保留在存储中的原始位置 |

#### <a name="directory-based-projects"></a>基于目录的项目
下表汇总了拖放 (以及应该根据为基于目录的目标项目按下的源项和修改键的性质执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 `CF_HDROP` ()  |
|-----------------|----------| - | - |
| 无修饰符 | 操作 | 移动 | 移动 |
| 无修饰符 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 无修饰符 | 源 | 删除对原始项的引用 | 删除对原始项的引用 |
| Shift+拖动 | 操作 | 移动 | 移动 |
| Shift+拖动 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| Shift+拖动 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| Shift+拖动 | 结果 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+拖动 | 操作 | 复制 | 复制 |
| Ctrl+拖动 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| Ctrl+拖动 | 源 | 保留对原始项的引用 | 保留对原始项的引用 |
| Ctrl+拖动 | 结果 | `DROPEFFECT_COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+Shift+拖动 | | 无删除 | 无删除 |
| 剪切/粘贴 | 操作 | 移动 | 移动 |
| 剪切/粘贴 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 剪切/粘贴 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| 剪切/粘贴 | 结果 | 项保留在存储中的原始位置 | 从存储中的原始位置删除项 |
| 复制/粘贴 | 操作 | 复制 | 复制 |
| 复制/粘贴 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| 复制/粘贴 | 源 | 保留原始项 | 保留原始项 |
| 复制/粘贴 | 结果 | 项保留在存储中的原始位置 | 项保留在存储中的原始位置 |

#### <a name="mixed-target-projects"></a>混合目标项目
下表汇总了拖放 (，以及基于为混合目标项目按下的源项和修改键的性质，应执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 (`CF_HDROP`)  |
| --- | --- | --- | --- |
| No 修饰符 | 操作 | 移动 | 移动 |
| No 修饰符 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| No 修饰符 | 源 | 删除对原始项的引用 | 删除对原始项的引用 |
| No 修饰符 | 结果 | `DROPEFFECT_ MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ MOVE` 作为的操作返回 `::Drop` ，从存储中的原始位置删除项 |
| Shift + 拖动 | 操作 | 移动 | 移动 |
| Shift + 拖动 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| Shift + 拖动 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| Shift + 拖动 | 结果 | `DROPEFFECT_ MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ MOVE` 作为的操作返回 `::Drop` ，从存储中的原始位置删除项 |
| Ctrl + 拖动 | 操作 | 复制 | 复制 |
| Ctrl + 拖动 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| Ctrl + 拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl + 拖动 | 结果 | `DROPEFFECT_ COPY` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ COPY` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| Ctrl + Shift + 拖动 | 操作 | 链接 | 链接 |
| Ctrl + Shift + 拖动 | 目标 | 添加对原始项的引用 | 添加对原始源项的引用 |
| Ctrl + Shift + 拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl + Shift + 拖动 | 结果 | `DROPEFFECT_ LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| 剪切/粘贴 | 操作 | 移动 | 移动 |
| 剪切/粘贴 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 剪切/粘贴 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| 剪切/粘贴 | 结果 | 项目保留在存储中的原始位置 | 从存储中的原始位置删除项目 |
| 复制/粘贴 | 操作 | 复制 | 复制 |
| 复制/粘贴 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| 复制/粘贴 | 源 | 保留原始项 | 保留原始项 |
| 复制/粘贴 | 结果 | 项目保留在存储中的原始位置 | 项目保留在存储中的原始位置 |

在 **解决方案资源管理器** 中实现拖动时，应考虑这些详细信息：

- 设计多选方案。

- 文件名称 (完整路径) 在目标项目中必须是唯一的，否则不允许放置。

- 文件夹名称必须是唯一的， (不区分大小写的) 。

- 在拖动时打开或关闭的文件之间存在行为差异 (未在上述方案中提到) 。

- 顶级文件的行为与文件夹中的文件略有不同。

要注意的另一个问题是如何处理已打开设计器或编辑器的项的移动操作。 预期行为如下 (这适用于所有项目类型) ：

1. 如果打开的编辑器/设计器没有任何未保存的更改，则编辑器/设计器窗口应以静默方式关闭。

2. 如果打开的编辑器/设计器确实有未保存的更改，则拖动的源应等待放置操作，然后要求用户在关闭窗口之前保存打开的文档中未提交的更改，并提示如下：

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

这为用户提供了在目标创建副本之前保存正在进行的工作的机会。 添加了一种新方法 `IVsHierarchyDropDataSource2::OnBeforeDropNotify` 来启用此处理。

然后，目标将复制项在存储中的状态，如果用户选择 " **无** ") ，则不在编辑器中包含未保存的更改 (不包含未保存的更改。 目标完成其复制 (`IVsHierarchyDropDataSource::Drop`) 后，就有机会在) 中完成移动操作 (删除部分 `IVsHierarchyDropDataSource::OnDropNotify` 。

具有未保存更改的任何编辑器都应保持打开状态。 对于包含未保存更改的文档，这意味着将执行移动操作的复制部分，但会中止删除部分。 在多选方案中，当用户选择 " **否**" 时，不应关闭或删除那些具有未保存更改的文档，而不保存更改的文档应关闭并删除。
